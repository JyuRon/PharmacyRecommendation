1. JpaRepository 에서 command + option + b 를 누르면 해당 인터페이스를 구현한 SimpleJpaRepository 를 확인할 수 있다.
    => JPA 의 모든 데이터 변경은 Transaction 에서 일어난다.
    => save메소드 구현 코드를 보면 em.persist를 통해 영속성 컨텍스트에 저장
        이때, entity는 영속상태
        이미 영속성태인 경우 merge를 통해 덮어 쓴다.


2. 영속성 컨텍스트?
- entity를 저장하고 관리하는 저장소이며 어플리케이션과 데이터베이스 사이에 entity를 보관하는 가상의 데이터베이스 같은 역할
- 1차 캐시 역할
    * 영속성 컨텍스트 내부에 1차 캐시를 가지고 있다. persist를 하는 순간 pk값(id), 타입과 객체를 맵핑 하여 1차 캐시에 가지고 있음
    * 한 트랜잭션 내에 1차 캐시에 이미 있는 값을 조회하는 경우 DB를 조회 하지 않고 1차 캐시에 있는 내용을 그대로 가져온다.
    * 단, 1차 캐시는 어플리케이션 전체 공유가 아닌 한 트랜잭션 내에서만 공유
    * 반면, 조회 했을 때 1차 캐시에 없다면 DB에서 가져와서 1차 캐시에 저장 후 반환
- 쓰기 지연 SQL 저장소
    * memberA를 persist 하는 순간, 1차 캐시에 넣고 쓰기 지연 SQL 저장소에 쿼리를 만들어 쌓는다.
    * memberB도 persis하는 순간 동일한 과정을 거치며, commit 하는 순간 flush가 되면서 DB에 반영
    * flush란 영속성 컨텍스트의 변경 내용을 DB에 반영하며, 1차 캐시를 지우지는 않는다.
    * 예외의 경우 DB 에게 위임한 @GenerateValue id 값이 필요한 경우 경우 바로 쓰기 지연 SQL 저장소를 거치지 않는다.
- 스냅샷
    * 1차 캐시에는 처음 들어온 상태인 엔티티 스냅샷을 넣어두고 DirtyChecking 을 활용하는데 사용된다.



3. 엔티티 수정(Dirty Checking)
- JPA에서 트랜잭션이 끝나는 시점에 변화가 있는 모든 entity 객체를 데이터 베이스에 자동으로 반영해 준다.
    * 영속성 컨텍스트(1차캐시)에 처음 저장된 순간 스냅샷을 저장
    * JPA는 commit 직전 내부적으로 flush가 호출되고, 이때 엔티티와 스냅샷을 비교
    * entity 변경된 값이 있는지 비교하여 변경된 값이 있으면 update 쿼리를 쓰기 지연 SQL에 넣어둔다.
    * 트랜잭션 종료(commit) 시 쓰기 지연 SQL 저장소의 쿼리를 실행한다.
- 당연히 Dirty Checking은 영속성 컨텍스트가 관리하는 entity에만 적용된다.
    => 트랜잭션이 없이 데이터 변경 반영이 일어나지 않는다